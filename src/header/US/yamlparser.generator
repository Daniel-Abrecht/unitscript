#ifndef US_YAMLPARSER_GENERATOR
#define US_YAMLPARSER_GENERATOR

#include <stdio.h>
#include <stdbool.h>
#include <stddef.h>
#include <US/utils.h>

struct us_parser;

#ifdef PARSABLE_STRUCTURES

#define BLOCK(X,Y) typedef struct us_ ## X us_ ## X ## _t;
#define ENTRY(X,Y,Z)
PARSABLE_STRUCTURES
#undef ENTRY
#undef BLOCK

#define BLOCK(X,Y) struct us_ ## X {US_UNPACK Y};
#define ENTRY(X,Y,Z) us_ ## X ## _t* Z;
PARSABLE_STRUCTURES
#undef ENTRY
#undef BLOCK

#define BLOCK(X,Y) bool parse_yaml_ ## X( struct us_parser*, us_ ## X ## _t** );
#define ENTRY(X,Y,Z)
PARSABLE_STRUCTURES
#undef ENTRY
#undef BLOCK

#define BLOCK(X,Y) void free_yaml_ ## X( us_ ## X ## _t** );
#define ENTRY(X,Y,Z)
PARSABLE_STRUCTURES
#undef ENTRY
#undef BLOCK

#endif

bool parse_yaml(FILE* file, void** ret, bool(*)(struct us_parser* s, void** ret), void(*)(void** ret) );

bool parse_yaml_string( struct us_parser* s, us_string_t** ch );
bool parse_yaml_map( struct us_parser* s, us_map_t** ch );
bool parse_yaml_skip_unknown_mapping( struct us_parser* s );

void free_yaml_string( us_string_t** ch );
void free_yaml_map( us_map_t** ch );

#ifndef PARSE_YAML
#define PARSE_YAML( T, file, R ) \
  parse_yaml( \
    file, \
    (void**)((struct{us_ ## T ## _t** x;}){.x=(R)}).x, \
    (bool(*)(struct us_parser*,void**))((struct{bool(*x)(struct us_parser*,us_ ## T ## _t**);}){.x=(&parse_yaml_ ## T)}).x, \
    (void(*)(void**))((struct{void(*x)(us_ ## T ## _t**);}){.x=(&free_yaml_ ## T)}).x \
  )
#endif

#ifndef FREE_YAML
#define FREE_YAML( T, R ) free_yaml_ ## T( R )
#endif

#if defined( US_YAML_PARSER_INTERNALS ) || defined(US_GENERATE_CODE)
#include <yaml.h>

enum parser_state {
  PARSER_STATE_KEY,
  PARSER_STATE_VALUE,
  PARSER_STATE_MAPPING
};

typedef struct us_parser {
  yaml_parser_t* parser;
  const char* value;
  size_t length;
  enum parser_state state;
  bool done;
} us_parser_t;
#endif

#ifdef PARSABLE_STRUCTURES
#ifndef US_GENERATE_CODE
#undef PARSABLE_STRUCTURES
#else

#include <stdio.h>
#include <string.h>

#define ENTRY(X,Y,Z) \
  if( length == sizeof(Y)-1 && !memcmp(Y,key,length) ){ \
    if( !parse_yaml_ ## X( s, &c->Z ) ){ \
      yaml_token_delete(&token); \
      fprintf(stderr,"Failed to parse key %.*s\n",(int)length,key); \
      if(key) \
        free( key );\
      return false; \
    } \
  }else 

#define BLOCK(X,Y) \
  bool parse_yaml_ ## X( us_parser_t* s, us_ ## X ## _t** ch ){ \
    yaml_token_t token; \
    \
    if( s->state != PARSER_STATE_MAPPING ) \
      return false; \
    \
    size_t length = 0; \
    char* key = 0; \
    bool done = false; \
    \
    us_ ## X ## _t* c = calloc(1,sizeof(us_ ## X ## _t)); \
    if(!c){ \
      perror("calloc failed"); \
      s->done = true; \
      return false; \
    } \
    *ch = c; \
    \
    do { \
      \
      if( !yaml_parser_scan(s->parser, &token) ){ \
        fprintf(stderr,"yaml_parser_scan failed"); \
        s->done = true; \
        return false; \
      } \
      \
      bool next = false; \
      \
      switch( token.type ){ \
        case YAML_KEY_TOKEN: { \
          s->state = PARSER_STATE_KEY; \
        } break; \
        case YAML_VALUE_TOKEN: { \
          s->state = PARSER_STATE_VALUE; \
        } break; \
        case YAML_SCALAR_TOKEN: { \
          if( s->state == PARSER_STATE_KEY ){ \
            length = token.data.scalar.length; \
            key = malloc(length+1); \
            if(!key){ \
              perror("calloc failed"); \
              s->done = true; \
              return false; \
            } \
            memcpy(key,token.data.scalar.value,length); \
            key[length] = 0; \
          }else{ \
            s->value = (const char*)token.data.scalar.value; \
            s->length = token.data.scalar.length; \
            next = true; \
          } \
        } break; \
        case YAML_BLOCK_MAPPING_START_TOKEN: { \
          s->state = PARSER_STATE_MAPPING; \
          next = true; \
        } break; \
        case YAML_BLOCK_END_TOKEN: { \
          done = true; \
        } break; \
        default: break; \
      } \
      \
      if( next && ( s->state == PARSER_STATE_MAPPING || s->state == PARSER_STATE_VALUE ) ){ \
        US_UNPACK Y { \
          fprintf(stderr,"Warning: unknown key %.*s\n",(int)length,key); \
          if( s->state == PARSER_STATE_MAPPING ){ \
            parse_yaml_skip_unknown_mapping( s ); \
          } \
        } \
        if(key) \
          free( key );\
        key = 0; \
      } \
      \
      s->done = token.type == YAML_STREAM_END_TOKEN; \
      yaml_token_delete(&token); \
      \
    } while( !s->done && !done ); \
    \
    if(key) \
      free( key );\
    \
    return true; \
  }

PARSABLE_STRUCTURES

#undef BLOCK
#undef ENTRY

#define BLOCK(X,Y) void free_yaml_ ## X( us_ ## X ## _t** ch ){ \
  us_ ## X ## _t* c = *ch; \
  if(!c) return; \
  *ch = 0; \
  US_UNPACK Y \
  free(c); \
}

#define ENTRY(X,Y,Z) free_yaml_ ## X(&c->Z);

PARSABLE_STRUCTURES

#undef ENTRY
#undef BLOCK


#undef PARSABLE_STRUCTURES

#endif
#endif

#endif
